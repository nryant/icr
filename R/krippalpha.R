#' Krippendorff's alpha
#'
#' \code{krippalpha} computes Krippendorff's reliability coefficient alpha.
#'
#' @param data a matrix of reliability data.
#' @param metric metric difference function to be applied to disagreements. Supports \code{nominal}, \code{ordinal}, \code{interval}, and \code{ratio}. Defaults to \code{nominal}.
#' @param bootstrap a logical indicating whether uncertainty estimates should be obtained using the bootstrap algorithm defined by Krippendorff. Defaults to \code{FALSE}.
#' @param bootnp a logical indicating whether non-parametric bootstrap uncertainty estimates should be computed. Defaults to \code{FALSE}.
#' @param nboot number of bootstraps used in Krippendorff's algorithm. Defaults to \code{20000}.
#' @param nnp number of non-parametric bootstraps. Defaults to \code{1000}.
#' @param cores number of cores across which bootstrap-computations are distributed. Defaults to 1. If more cores are specified than available, the number will be set to the maximum number of available cores.
#' @param custom_seed seed vector of length 6 for the internal L'Ecuyer-CMRG random number generator. Defaults to \code{NULL}. When set to NULL, relies on R's \code{.Random.seed} vector.
#'
#' @details For proper seeding of \code{krippalpha}'s bootstrap-routines via R, specify \code{set.seed(seed, kind = "L'Ecuyer-CMRG")}. Please note that \code{krippalpha} takes the \code{.Random.seed} vector generated by R to seed the internal random number generator of both bootstrap-routines. Furthermore, it does not advance R's RNG state. Hence, \code{.Random.seed} will be the same after \code{krippalpha} has been run.
#'
#' @return Returns a list of type \code{icr} with following elements:
#' \item{alpha}{value of inter-coder reliability coefficient}
#' \item{method}{data level of x}
#' \item{n_coders}{number of coders}
#' \item{n_units}{number of units to be coded}
#' \item{n_values}{number of unique values in reliability data}
#' \item{coincidence_matrix}{matrix containing coincidences within coder-value pairs}
#' \item{delta_matrix}{matrix of metric differences depending on \code{method}}
#' \item{D_e}{expected disagreement}
#' \item{D_o}{observed disagreement}
#' \item{bootstrap}{logical value. \code{TRUE} if Krippendorff bootstrapping algorithm was run}
#' \item{nboot}{number of bootstraps}
#' \item{bootnp}{logical value. \code{TRUE} if nonparametric bootstrap was run}
#' \item{nnp}{number of non-parametric bootstraps}
#' \item{bootstraps}{vector of bootstrapped values of alpha (Krippendorff's algorithm)}
#' \item{bootstrapsNP}{vector of non-parametrically bootstrapped values of alpha}
#'
#' @note \code{krippalpha}'s bootstrap-routines use L'Ecuyer's CMRG random number generator (see L'Ecyuer et al. 2002) to create random numbers suitable for parallel computations. The routines interface to L'Ecuyer's C++ code, which can be found at \url{https://pubsonline.informs.org/doi/abs/10.1287/opre.50.6.1073.358}
#'
#' @references
#' Krippendorff, K. (2004) \emph{Content Analysis: An Introduction to Its Methodology}. Beverly Hills: Sage.
#'
#' Krippendorff, K. (2011) \emph{Computing Krippendorff's Alpha Reliability}. Departmental Papers (ASC) 43. \url{http://repository.upenn.edu/asc_papers/43}.
#'
#'Krippendorff, K. (2016) \emph{Bootstrapping Distributions for Krippendorff's Alpha}. \url{http://web.asc.upenn.edu/usr/krippendorff/boot.c-Alpha.pdf}.
#'
#' L'Ecuyer, P. (1999) Good Parameter Sets for Combined Multiple Recursive Random Number Generators. \emph{Operations Research}, 47 (1), 159--164. \url{https://pubsonline.informs.org/doi/10.1287/opre.47.1.159}.
#'
#' L'Ecuyer, P., Simard, R, Chen, E. J., and Kelton, W. D. (2002) An Objected-Oriented Random-Number Package with Many Long Streams and Substreams. \emph{Operations Research}, 50 (6), 1073--1075. \url{http://www.iro.umontreal.ca/~lecuyer/myftp/streams00/c++/streams4.pdf}.
#'
#' @examples
#' data(codings)
#' krippalpha(codings)
#' krippalpha(codings, metric = "nominal", bootstrap = TRUE, bootnp = TRUE)
#'
#' @useDynLib icr, .registration = TRUE
#' @importFrom Rcpp evalCpp
#' @export
krippalpha <- function(data, metric = "nominal",
                           bootstrap = FALSE, bootnp = FALSE,
                           nboot = 20000, nnp = 1000, cores = 1, custom_seed = NULL) {
    if (is.null(custom_seed)) {
        cmrg_seed <- .Random.seed[2:7]
    } else if (length(custom_seed) == 6) {
        cmrg_seed <- custom_seed
    } else {
        stop("L'Ecuyer-CMRG seed requires an integer vector of length 6.\n")
    }
    result <- alpha_k_cpp(data, metric, bootstrap, bootnp, nboot, nnp, cmrg_seed, cores)
    class(result) <- "icr"
    return(result)
}
